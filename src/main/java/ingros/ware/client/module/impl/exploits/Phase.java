package ingros.ware.client.module.impl.exploits;

import ingros.ware.client.events.*;
import ingros.ware.client.mixin.accessors.IEntityPlayerSP;
import ingros.ware.client.module.Module;
import ingros.ware.client.utils.TimerUtil;
import ingros.ware.client.utils.value.impl.EnumValue;
import ingros.ware.client.utils.value.impl.NumberValue;
import net.b0at.api.event.Subscribe;
import net.b0at.api.event.types.EventType;
import net.minecraft.block.Block;
import net.minecraft.block.BlockAir;
import net.minecraft.block.BlockHopper;
import net.minecraft.block.BlockLiquid;
import net.minecraft.block.state.IBlockState;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.BlockPos;
import net.minecraft.util.MathHelper;

public class Phase extends Module {
    public Phase() {
        super("Phase", Category.EXPLOITS, 0xff00ffff);
    }


    @Subscribe
    public void onUpdate(UpdateEvent event) {
        double multiplier = 0.163;
        double mx = Math.cos(Math.toRadians(getMc().thePlayer.rotationYaw + 90.0));
        double mz = Math.sin(Math.toRadians(getMc().thePlayer.rotationYaw + 90.0));
        double x = getMc().thePlayer.movementInput.moveForward * multiplier * mx + getMc().thePlayer.movementInput.moveStrafe * multiplier * mz;
        double z = getMc().thePlayer.movementInput.moveForward * multiplier * mz - getMc().thePlayer.movementInput.moveStrafe * multiplier * mx;
        if (getMc().thePlayer.isCollidedHorizontally && !getMc().thePlayer.isOnLadder() && !isInsideBlock()) {
            getMc().thePlayer.sendQueue.addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(getMc().thePlayer.posX + x,
                    getMc().thePlayer.posY, getMc().thePlayer.posZ + z, false));
            getMc().thePlayer.sendQueue.addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(getMc().thePlayer.posX,
                    getMc().thePlayer.posY - 0.5, getMc().thePlayer.posZ,
                    false));
        }
    }

    @Subscribe
    public void onBlock(BoundingBoxEvent event) {
        if (getMc().thePlayer == null) return;
        getMc().thePlayer.noClip = true;
        if (event.getBlockPos().getY() > getMc().thePlayer.posY + (isInsideBlock() ? 0 : 1)) event.setBoundingBox(null);
        if (getMc().thePlayer.isCollidedHorizontally && event.getBlockPos().getY() > getMc().thePlayer.getEntityBoundingBox().minY - 0.4)
            event.setBoundingBox(null);
    }
    private boolean isInsideBlock() {
        for (int x = MathHelper.floor_double(getMc().thePlayer.getEntityBoundingBox().minX); x < MathHelper.floor_double(getMc().thePlayer.getEntityBoundingBox().maxX) + 1; x++) {
            for (int y = MathHelper.floor_double(getMc().thePlayer.getEntityBoundingBox().minY); y < MathHelper.floor_double(getMc().thePlayer.getEntityBoundingBox().maxY) + 1; y++) {
                for (int z = MathHelper.floor_double(getMc().thePlayer.getEntityBoundingBox().minZ); z < MathHelper.floor_double(getMc().thePlayer.getEntityBoundingBox().maxZ) + 1; z++) {
                    Block block = getMc().theWorld.getBlockState(new BlockPos(x, y, z)).getBlock();
                    if ((block != null) && (!(block instanceof BlockAir))) {
                        AxisAlignedBB boundingBox = block.getCollisionBoundingBox(getMc().theWorld, new BlockPos(x, y, z), getMc().theWorld.getBlockState(new BlockPos(x, y, z)));
                        if ((block instanceof BlockHopper)) {
                            boundingBox = new AxisAlignedBB(x, y, z, x + 1, y + 1, z + 1);
                        }
                        if ((boundingBox != null) && (getMc().thePlayer.getEntityBoundingBox().intersectsWith(boundingBox))) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
}